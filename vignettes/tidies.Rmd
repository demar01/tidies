---
title: "A Grammar of Data Manipulation for Omics Experiments"
author: Laurent Gatto
package: tidies
output:
  BiocStyle::html_document:
   toc_float: true
vignette: >
  %\VignetteIndexEntry{tidyies}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteKeyword{omics, proteomics, transcriptomics, data science, tidyverse}
  %\VignetteEncoding{UTF-8}
---

```{r env, echo=FALSE, message=FALSE}
suppressPackageStartupMessages(library("tidies"))
suppressPackageStartupMessages(library("BiocStyle"))
suppressPackageStartupMessages(library("MSnbase"))
```

# Introduction
The `tidies` package (from to contraction of *tidy* `eSet`) implements
tidy principles as defined in
the [tidyverse](https://www.tidyverse.org/) packages to omics-type
data based on the `eSet` class, with (currently at least for now), an
emphasis on quantitative proteomics data.

## High throughput data and the `eSet` class

The motivation to store omics data in dedicated containers is to
coordinate the high throughput data (e.g., gene or protein
expression), the sample annotation (phenotype data) and the feature
annotation (feature data).

A typical omics data structure, as defined by
the
[`eSet`](https://bioconductor.org/packages/release/bioc/vignettes/Biobase/inst/doc/BiobaseDevelopment.pdf) class,
is represented below. It's main features are

- An assay data slot containing the quantitative omics data
  (expression data), stored as a `matrix` and accessible with `exprs`.
  Features defined along the rows and samples along the columns.

- A sample metadata slot containing sample co-variates, stored as an
  annotated `data.frame` and accessible with `pData`. This data frame
  is stored with rows representing samples and sample covariate along
  the columns, and its rows match the expression data columns exactly.

- A feature metadata slot containing feature co-variates, stored as an
  annotated `data.frame` and accessible with `fData`. This dataframe's
  rows match the expression data rows exactly.

![A typical omics data object](./msnset.png)

The coordinated nature of the high throughput data guarantees that the
dimensions of the different slots will always match (i.e the columns
in the expression data and then rows in the sample metadata, as well
as the rows in the expression data and feature metadata) during data
manipulation. The metadata slots can grow additional co-variates
(columns) without affecting the other structures.


To illustrate such an omics data container, we'll make use of the
`msnset` object that comes with the `r Biocpkg("MSnbase")` package,
which contains data for `r nrow(msnset)` features and `r ncol(msnset)`
samples.


```{r msnset}
library("MSnbase")
data(msnset)

## Some test sample groups
msnset$group <- c("A", "A", "B", "B")
dim(msnset)
```

The expression data:

```{r exprs}
exprs(msnset)
```

The sample metadata:

```{r pData}
pData(msnset)
```

The feature metadata:

```{r fData}
fData(msnset)[1:10, 1:5]
## all feature variables
fvarLabels(msnset)
```
## Tidy tools

The [*tidy data*](https://www.jstatsoft.org/article/view/v059i10)
definition
and
[tidy tools manifesto](http://tidyverse.tidyverse.org/articles/manifesto.html) and
lay out the principles that packages in the tidyverse
package. `tidies` isn't part of the this `tidyvers`, but aims at
applying these same principles. The concepts that are relevant for the
application to omics data are

- Reuse of existing data structures; in this case `eSet` objects, that
  constitute our *tidy* omics data.

- Compose simple functions with the pipe; here we apply the widely
  used `r CRANpkg("dplyr")` functions and `r CRANpkg("magrittr")`
  `%>%` operator.

- Each of the adapted tidy function to use and return tidy `eSet`
  data.

# Examples

We start by loading the `tidies` package (which also automatically
loads and attached `r CRANpkg("magrittr")` for the `%>%` operator).

```{r loadpackage}
library("tidies")
```

## Order data by it feature of sample variables

```{r arrange}
## Arrange columns/samples
msnset %>%
	arrange(desc(group)) %>%
	pData

## All feature variables
fvarLabels(msnset)

## Select a feature variable
msnset %>%
	select(charge) %>%
	fvarLabels

## Arrange rows/features and select feature variables
msnset %>%
	arrange(charge) %>%
	select(charge) %>%
	fData %>% head
```

## Return features and samples with matching conditions

```{r filter}
## Filter using feature variables
msnset %>%
	filter(ProteinAccession == "ENO") %>%
	exprs

## Filter using phenotypic (samples) variables
msnset %>%
	filter(group == "A") %>%
	exprs %>%
	head

## Filter on both feature and sample variables
msnset %>%
	filter(group == "A") %>%
	filter(ProteinAccession == "ENO") %>%
	exprs
```

## Select feature or sample variables

```{r select}
## Select sample variables (updates only the phenotypic data)
msnset %>%
	select(group) %>%
	pData

## Select feature variables (updates only the feature data)
msnset %>%
	select(starts_with("Protein")) %>%
	fvarLabels

## Select sample and feature variables
msnset %>%
	select(group) %>%
	select(starts_with("Prot"))
```

## Group by one or more feature or sample variables

```{r groupby}
## Group by features
msnset %>%
	group_by(ProteinAccession)

## Group by samples
msnset %>%
	group_by(group)

## Group by features and samples
msnset %>%
	group_by(ProteinAccession) %>%
	group_by(group)
```

## Summarise the expression values of a dataset

```{r summarise}
## Grouping and summarising by features
msnset %>% group_by(charge) %>%
	summarise(median(exprs, na.rm = TRUE)) %>%
	exprs

msnset %>% group_by(ProteinAccession) %>%
	summarise(median(exprs, na.rm = TRUE)) %>%
	exprs %>%
	head

## Grouping and summarising by samples
msnset %>% group_by(group) %>%
	summarise(mean(exprs, na.rm = TRUE)) %>%
	exprs %>%
	head
## Grouping by features and samples
msnset %>%
	group_by(charge) %>%
	summarise(mean(exprs)) %>%
	group_by(group) %>%
	summarise(max(exprs, na.rm = TRUE)) %>%
	exprs
```
